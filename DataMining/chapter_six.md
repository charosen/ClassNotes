## Chapter 6. 挖掘频繁模式、关联和相关性：基本概念与方法

<h3 id='6.1.'>一、基本概念(Basic Concepts)</h3>

<h4 id='6.1.1.'>1. 为什么频繁模式如此重要？</h4>

1. 数据集中固有的、重要的属性；
2. 许多数据挖掘任务的基础；

<h4 id='6.1.2.'>2. 基本概念：频繁模式</h4>

1. 频繁模式(Frequent patterns)：
    1. 定义：频繁出现的模式（模式可以是项集itemset、子序列subsquence、子结构substructure...）；
    2. 分类：频繁项集、频繁子序列、频繁子结构；
2. 频繁项集（Frequent Itemset）相关概念：
    1. 项集（Itemset)：项的集合；
    2. k项集（k-itemset)：包含k个项的项集；
    3. 绝对支持度：项集出现的频数（包含项集的事务数）；
    4. 相对支持度：项集出现的频率；
    5. 频繁项集的定义：频率（相对支持度）超过最小支持度阈值的项集；（**此阈值是超参数，由人为根据应用场景设置，并非算法自身调节**）;

<h4 id='6.1.3.'>3. 基本概念：关联规则</h4>

1. 关联规则(Association Rules)相关概念：
    1. 关联规则定义：形如`X->Y`的蕴含式，
        + X, Y非空，X, Y的交集为空集（人们更关心项集互斥情况）；
        + 有属性：
            + 支持度（注意与项集的支持度区别）：项集X, Y的并集发生的概率$support(X->Y) = support(X \cup Y) = p(X \cup Y)$；
            + 置信度：项集X为条件，项集Y发生的条件概率$conf(X->Y) = \frac{support(X \cup Y)}{support(X)}$；
    2. 关联规则意义：表征项集X, Y之间的关联程度； 
    3. 强关联规则定义：满足最小支持度、最小置信度的关联规则；
        1. 支持度表征频繁程度，置信度表征关联程度，只有频繁，关联都满足的规则才是强关联规则；
        2. 相同频繁项生成的关联规则，其支持度是相同的（很好理解）；


<h4 id='6.1.4.'>4. 闭频繁项集和极大频繁项集</h4>

1. 闭频繁模式（闭频繁项集）：当项集满足
    1. 频繁的；
    2. 闭的：不存在真超项集Y，使得Y和X具有相同支持度（父项集支持度$\le$子项集支持度，不等于即小于，所以闭项集是包含该项集、支持度最大的频繁项集）；
2. 极大频繁模式（极大频繁项集）：当项集满足
    1. 频繁的；
    2. 不存在频繁的真超项集Y（条件比闭频繁项集更严格）；
3. 闭频繁项集属性：闭频繁项集是频繁项集的一个无损子集（包含了频繁项集的完整信息<=闭频繁项集及其子集构成所有频繁项集）；
4. 项集包含关系： 极大频繁项集 < 闭频繁项集 < 频繁项集；
  
  ![](./img/itemset_relations.png)

<h3 id='6.2.'>二、频繁项集挖掘算法(Frequent Itemset Mining Methods)</h3>

<h4 id='6.2.1.'>1. Apriori算法</h4>

1. 算法思想:
    1. 先验性质(Apriori principle)：频繁项集的所有非空子集必频繁（子集频率>=原频繁项集频率）；
    2. 先验性质的逆否命题：某项集非频繁 --> 该项集的任意超集均非频繁；
    3. 先验性质--属于-->反单调性质（一个集合不能通过测试，则其所有超集都不能通过测试）；
    4. 支持度的反单调性：子集频率>=原频繁项集频率；
2. 算法实现（两个核心阶段：候选集生成，测试候选集）：
    1. 初始化，扫描数据库，得到所有频繁一项集的集合；
    2. 从频繁(k-1)项集的集合生成k项候选集：
        1. 连接步：频繁(k-1)项集的集合自连接生成k项候选集；
            1. 自连接预处理：频繁(k-1)项集按字母顺序排序项集；
            2. 自连接执行条件：
                1. 前k-2项相同（这样连接才是k项集）；
                2. 按字母顺序连接最后一项（避免重复）；
        2. 剪枝步：由先验性质，用频繁(k-1)项集的集合来对k项候选集的所有子集进行检查，剪枝并压缩候选集；
    3. 对候选集进行支持度计数（先剪枝后计数，减少计算复杂度）：
        1. 算法实现--使用hash树进行支持度计数：
            1. 生成候选集的hash树，需要：
                1. hash function：不唯一，输入--映射-->输出，内容决定位置；
                2. max leaf size：叶子节点存储的最大项集数，超过max leaf size则向下分支；
            2. 使用hash树进行subset operation并支持度计数：
                + 依据hash函数，将事务数据放到候选集生成的hash树上游走，游走得到事务数据包含的所有可能k项集，并支持度计数，而不用和候选集的所有项集一一比较，减少计算复杂度；
                + 在叶子节点才进行比较，中间节点处一直使用hash函数来进行映射（选路）；

    4. 反复迭代，直到无频繁项集或候选集生成则终止；

<h4 id='6.2.2.'>2. Apriori算法的改进</h4>

1. 数据量增大时，Apriori算法的计算复杂度面临挑战：
    1. 多次遍历数据库 <-- 每轮支持度计数都要遍历数据库(数据库规模过大，I/O操作数据库，速度慢)；
    2. 大量候选集 <-- 每轮自连接生成大量候选集，包括很多冗余候选集；
    3. 候选集的冗余支持度计数 <-- 剪枝只去除部分冗余候选集，还会对很多非频繁的冗余候选集计数；
2. 改进方法：
    1. 划分(Partition)：只扫描数据库两次
        1. 思想：大数据库频繁项—>至少在某子数据库中为频繁项，但是逆命题不一定成立（子数据库频繁项不一定是大数据库的频繁项）；
        2. 算法实现：
            1. scan_one：将数据库划分成几个分区（分区小到可以存入内存中进行操作，无需I/O操作数据库），分区在内存中跑Aprior算法得到局部频繁项集(local frequent itemset)-->第一次I/O扫描数据库；
            2. scan_two：对所有分区的局部频繁项集进行验证（全局支持度是否>=最小支持度阈值）-->第二次I/O扫描数据库；
    2. 使用散列计数生成候选集：减小生成的候选集；
        1. 思想：使用散列计数和频繁项集定义，删除多个非频繁的冗余候选集
    3. 抽样(Sampling)：扫描数据库1~2次
        1. 思想：在数据集D的一个简单随机样本S（小到可以存入内存）进行频繁模式挖掘，得到近似最优解，可能会丢解；

<h4 id='6.2.3.'>3. FPGrowth算法（Frequent Pattern-Growth Approach）</h4>

1. 算法思想：`长频繁项集`由`短频繁项集`和`局部频繁项集`（绝对支持度>全局最小支持度阈值）增长得到；
    1. 已知`短频繁项集`（条件模式基左侧对应的项）；
    2. 生成`短频繁项集`的投影数据库（包含`短频繁项集`的所有事务数据构成的子数据库）；
    3. 在`短频繁项集`的投影数据库中挖掘`局部频繁项集`（本质上，`局部频繁项集`的绝对支持度==`短频繁项集`+`局部频繁项集`同时发生/`长频繁项集`的绝对支持度）；
    4. 则 `长频繁项集` = `短频繁项集`+`局部频繁项集`一定是频繁项集（注意与先验性质区别）
2. 算法实现：
    1. 扫描数据库，得到频繁一项集，并按支持度降序排列得到列表f-list；
    2. 构建头表（Header table）：由f-list构建；
    3. 构建FP树：第二次扫描数据库，排序事务数据并删除事务数据中的非频繁部分，然后构建分支；
        1. 所有共享前缀节点计数+1；
        2. 前缀之后的项创建节点和连接；
    4. 挖掘FP树：
        1. 划分投影Partition Projection：从f-list末尾倒序挖掘条件模式基，即从树的底部回溯（原因：二项划分[能够完备且无冗余划分得到所有子集]且f-list最后一项必是FP树的叶子节点）；
        2. 深度优先递归构建条件模式基/投影数据库，其中数据的支持度 = 节点链上元素计数，并构建条件频繁模式树，递归挖掘条件频繁模式树；
        3. **递归终止条件：树退化成链或点；**当FP树退化为链时，各节点的排列组合得到频繁模式，支持度==各节点的最小支持度；
3. FPGrowth算法与Apriori算法性能比较：
    1. 性能：当支持度阈值设的比较小时，FPGrowth运行速度更快；
    2. 原因：当阈值越小时，Apriori生成的候选集越多，冗余越大，所以越慢；
4. FPGrowth算法优点：
    1. 只扫描数据库两次；
    2. 不生成候选集，不需验证候选集；
    3. 将事务数据压缩到FP树结构中；

<h4 id='6.2.4.'>4. ECLAT算法(Equivalent CLAss Transformation)</h4>

1. 两种数据格式（两种视角观察数据）：
    1. 水平数据格式(Horizontal Data Format)：横向观察数据，TID--Itemset格式；
    2. 垂直数据格式(Vertical Data Format)：纵向观察数据，Item--TID_set格式；
2. 算法思想：以垂直数据格式来使用Apriori算法；
3. 算法实现：
    1. 初始化，遍历数据库，将数据转换成垂直数据格式，获得频繁1项集的集合；
    2. 从频繁(k-1)项集的集合生成k项候选集；
        1. 连接步：频繁(k-1)项集的集合自连接，取交集得到k项候选集；
        2. 剪枝步：由先验性质，用频繁(k-1)项集的集合来对k项候选集的所有子集进行检查，剪枝并压缩候选集；
    3. 无需对候选集进行支持度计数；
    4. 反复迭代，知道无频繁项集或候选集生成而终止；　
4. ECLAT算法优点：
    1. 无需对候选集进行支持度计算（k项候选集的支持度信息包含在频繁k-1项集的集合中）；
    2. 只遍历数据库一次；
5. ECLAT算法缺点：
    1. 数据量很大时，tid-list很占内存，且对tid-list取交集计算开销很大（可以只记录差集来改进）；

